{{#types.hasLinkedList}}
class ListNode:
  def __init__(self, val=0, next=None):
    self.val = val
    self.next = next

  def _to_list(self):
    l = []
    c = self
    while c != None:
      l.append(c.val)
      c = c.next
    return l

  @staticmethod
  def _from_list(input):
    if len(input) == 0:
      return None

    r = ListNode(input.pop(0))
    for x in input:
      r.next = ListNode(x)
      r = r.next
    return r
{{/types.hasLinkedList}}

{{{userCode}}}

try:
  del _main
except:
  pass

def _main():
  import json
  {{{inputIdent}}} = json.loads(r'{{{escPythonRaw inputJson}}}')

  for tc in {{{inputIdent}}}:
    try:
      result = {{{challengeIdent}}}(tc)
      {{#if types.output.isDictionary}}
      j = json.dumps({
        r'{{{escPythonRaw boundary.dictionary}}}': { 'inner': [(k, v) for k, v in result.items()] }
      })
      {{else if types.output.isLinkedList}}
      j = json.dumps({
        r'{{{escPythonRaw boundary.linkedList}}}': { 'inner': result._to_list() }
      })
      {{else}}
      j = json.dumps(result)
      {{/if}}

    except Exception as e:
      j = json.dumps({ r'{{{escPythonRaw boundary.error}}}': { 'message': str(e) } })
    print('{}{}{}'.format(r'{{{escPythonRaw boundary.start}}}', j, r'{{{escPythonRaw boundary.end}}}'))

_main()
